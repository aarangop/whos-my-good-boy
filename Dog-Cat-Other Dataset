{"cells":[{"source":"<a href=\"https://www.kaggle.com/code/aarangop/dog-cat-other-dataset?scriptVersionId=236429148\" target=\"_blank\"><img align=\"left\" alt=\"Kaggle\" title=\"Open in Kaggle\" src=\"https://kaggle.com/static/images/open-in-kaggle.svg\"></a>","metadata":{},"cell_type":"markdown"},{"cell_type":"markdown","id":"1d4302cc","metadata":{"papermill":{"duration":0.005932,"end_time":"2025-04-27T14:00:54.076184","exception":false,"start_time":"2025-04-27T14:00:54.070252","status":"completed"},"tags":[]},"source":["# Dog-Cat-Other Dataset\n","\n","For my related project, where I try to build a cat, dog, or other classifier, to ultimately be able to recognize my own dog, I need labeled data. In this notebook we create a dataset for this task, based on a subset of the imagenet dataset, and the cat-and-dog dataset.\n","\n","We'll build a dataset that contains train, dev, and test sets, according to splits set by the user on this notebook.\n","\n","The dataset will consist of images placed inside folders that serve as class names. Since we only have three classes we can just use 'dog', 'cat', and 'other'."]},{"cell_type":"code","execution_count":1,"id":"90ebd1a2","metadata":{"execution":{"iopub.execute_input":"2025-04-27T14:00:54.085976Z","iopub.status.busy":"2025-04-27T14:00:54.085639Z","iopub.status.idle":"2025-04-27T14:00:54.097969Z","shell.execute_reply":"2025-04-27T14:00:54.096656Z"},"papermill":{"duration":0.019507,"end_time":"2025-04-27T14:00:54.100148","exception":false,"start_time":"2025-04-27T14:00:54.080641","status":"completed"},"tags":[]},"outputs":[],"source":["import os\n","import shutil\n","import json\n","import numpy as np"]},{"cell_type":"markdown","id":"b0a87589","metadata":{"papermill":{"duration":0.00346,"end_time":"2025-04-27T14:00:54.108046","exception":false,"start_time":"2025-04-27T14:00:54.104586","status":"completed"},"tags":[]},"source":["## Configuration"]},{"cell_type":"code","execution_count":2,"id":"0f2890cd","metadata":{"execution":{"iopub.execute_input":"2025-04-27T14:00:54.117459Z","iopub.status.busy":"2025-04-27T14:00:54.116563Z","iopub.status.idle":"2025-04-27T14:00:54.121522Z","shell.execute_reply":"2025-04-27T14:00:54.120453Z"},"papermill":{"duration":0.011661,"end_time":"2025-04-27T14:00:54.123421","exception":false,"start_time":"2025-04-27T14:00:54.11176","status":"completed"},"tags":[]},"outputs":[],"source":["train_size, dev_size, test_size = 0.8, 0.1, 0.1\n","\n","assert train_size + dev_size + test_size == 1, \"Train, dev, and test sizes must add up to 1!\""]},{"cell_type":"markdown","id":"1933c943","metadata":{"papermill":{"duration":0.003472,"end_time":"2025-04-27T14:00:54.131062","exception":false,"start_time":"2025-04-27T14:00:54.12759","status":"completed"},"tags":[]},"source":["## Write required functions"]},{"cell_type":"code","execution_count":3,"id":"5c5e1126","metadata":{"execution":{"iopub.execute_input":"2025-04-27T14:00:54.139448Z","iopub.status.busy":"2025-04-27T14:00:54.139121Z","iopub.status.idle":"2025-04-27T14:00:54.151063Z","shell.execute_reply":"2025-04-27T14:00:54.150105Z"},"papermill":{"duration":0.01816,"end_time":"2025-04-27T14:00:54.152777","exception":false,"start_time":"2025-04-27T14:00:54.134617","status":"completed"},"tags":[]},"outputs":[],"source":["def create_dataset_structure(output_path: str, exist_ok=False, reset=False):\n","    \"\"\"\n","    Creates the folder structure for a new cat/dog/other dataset\n","    \"\"\"\n","    \n","    if reset and os.path.exists(output_path):\n","        shutil.rmtree(output_path)\n","        \n","    for split in ['train', 'dev', 'test']:\n","        for category in ['dog', 'cat', 'other']:\n","            \n","            dirpath = os.path.normpath(f'{output_path}/{split}/{category}')\n","            os.makedirs(dirpath, exist_ok=exist_ok)\n","\n","\n","def get_cat_and_dog_dataset_image_paths():\n","    \n","    cats = []\n","    dogs = []\n","    \n","    def get_image_paths(dirpath, filenames):\n","        # Filter filenames by extension first\n","        filenames = filter(lambda f: os.path.splitext(f)[1].lower() == '.jpg', filenames)\n","        filenames = [os.path.normpath(f'{dirpath}/{f}') for f in filenames]\n","        \n","        return filenames\n","        \n","    for dirpath, dirnames, filenames in os.walk('/kaggle/input/cat-and-dog'):\n","        if os.path.basename(dirpath) == 'cats':\n","            new_cats = get_image_paths(dirpath, filenames)\n","            cats.extend(new_cats)\n","        elif os.path.basename(dirpath) == 'dogs':\n","            new_dogs = get_image_paths(dirpath, filenames)\n","            dogs.extend(new_dogs)\n","\n","    return cats, dogs\n","\n","def shuffle_split(lst, train_size, dev_size, test_size):\n","    number_of_samples = len(lst)\n","    splits = np.array([train_size, test_size, dev_size])\n","    split_sizes = np.floor(number_of_samples * splits).astype(int)\n","\n","    # Ensure the split sizes sum to the total number of samples\n","    if sum(split_sizes) != number_of_samples:\n","        # Add the difference to the largest split\n","        diff = number_of_samples - sum(split_sizes)\n","        split_sizes[np.argmax(splits)] += diff\n","    \n","    indices = np.arange(number_of_samples)\n","\n","    # Shuffle indices\n","    np.random.shuffle(indices)\n","    \n","    # Extract train indices\n","    train_indices = indices[:split_sizes[0]]\n","    \n","    # Extract test indices\n","    test_indices = indices[split_sizes[0]:split_sizes[0] + split_sizes[1]]\n","    \n","    # Extract dev indices\n","    dev_indices = indices[split_sizes[0] + split_sizes[1]:]\n","\n","    # Create the actual splits using the indices\n","    train_split = [lst[i] for i in train_indices]\n","    test_split = [lst[i] for i in test_indices]\n","    dev_split = [lst[i] for i in dev_indices]\n","    \n","    return train_split, test_split, dev_split"]},{"cell_type":"code","execution_count":4,"id":"d710d556","metadata":{"execution":{"iopub.execute_input":"2025-04-27T14:00:54.162093Z","iopub.status.busy":"2025-04-27T14:00:54.161761Z","iopub.status.idle":"2025-04-27T14:00:54.167203Z","shell.execute_reply":"2025-04-27T14:00:54.166459Z"},"papermill":{"duration":0.011782,"end_time":"2025-04-27T14:00:54.168726","exception":false,"start_time":"2025-04-27T14:00:54.156944","status":"completed"},"tags":[]},"outputs":[],"source":["cat_dog_other_root = 'cat-dog-other'\n","create_dataset_structure(cat_dog_other_root, exist_ok=True, reset=True)"]},{"cell_type":"markdown","id":"2f1b65bd","metadata":{"papermill":{"duration":0.003314,"end_time":"2025-04-27T14:00:54.175663","exception":false,"start_time":"2025-04-27T14:00:54.172349","status":"completed"},"tags":[]},"source":["## Moving cat-dog-dataset to cat-dog-other"]},{"cell_type":"code","execution_count":5,"id":"f9588c43","metadata":{"execution":{"iopub.execute_input":"2025-04-27T14:00:54.184132Z","iopub.status.busy":"2025-04-27T14:00:54.183785Z","iopub.status.idle":"2025-04-27T14:01:22.928396Z","shell.execute_reply":"2025-04-27T14:01:22.927158Z"},"papermill":{"duration":28.750756,"end_time":"2025-04-27T14:01:22.930045","exception":false,"start_time":"2025-04-27T14:00:54.179289","status":"completed"},"tags":[]},"outputs":[{"name":"stdout","output_type":"stream","text":["Collected 5011 cat images, and 5017 dog images\n"]}],"source":["# Get a list of all the filepaths for dogs, and cats from the cat-and-dog dataset.\n","cats, dogs = get_cat_and_dog_dataset_image_paths()\n","print(f'Collected {len(cats)} cat images, and {len(dogs)} dog images')"]},{"cell_type":"code","execution_count":6,"id":"8f0fbd8c","metadata":{"execution":{"iopub.execute_input":"2025-04-27T14:01:22.939153Z","iopub.status.busy":"2025-04-27T14:01:22.938856Z","iopub.status.idle":"2025-04-27T14:01:22.948902Z","shell.execute_reply":"2025-04-27T14:01:22.948076Z"},"papermill":{"duration":0.016452,"end_time":"2025-04-27T14:01:22.95046","exception":false,"start_time":"2025-04-27T14:01:22.934008","status":"completed"},"tags":[]},"outputs":[],"source":["# Shuffle the cat and dog images into train, test, and dev\n","train_size, test_size, dev_size = 0.8, 0.1, 0.1\n","cat_images = shuffle_split(cats, train_size, dev_size, test_size)\n","dog_images = shuffle_split(dogs, train_size, dev_size, test_size)"]},{"cell_type":"markdown","id":"7d20c814","metadata":{"papermill":{"duration":0.003414,"end_time":"2025-04-27T14:01:22.957665","exception":false,"start_time":"2025-04-27T14:01:22.954251","status":"completed"},"tags":[]},"source":["## Add cats and dogs images to dataset"]},{"cell_type":"code","execution_count":7,"id":"947d7fbf","metadata":{"execution":{"iopub.execute_input":"2025-04-27T14:01:22.96715Z","iopub.status.busy":"2025-04-27T14:01:22.966426Z","iopub.status.idle":"2025-04-27T14:02:39.864677Z","shell.execute_reply":"2025-04-27T14:02:39.863587Z"},"papermill":{"duration":76.908594,"end_time":"2025-04-27T14:02:39.869929","exception":false,"start_time":"2025-04-27T14:01:22.961335","status":"completed"},"tags":[]},"outputs":[{"name":"stdout","output_type":"stream","text":["0 files were skipped because they were already copied\n"]}],"source":["skipped = 0\n","for (class_name, splits) in zip(('cat', 'dog'), (cat_images, dog_images)):\n","    for (split, source) in zip(('train', 'test', 'dev'), splits):\n","        dest_dir = os.path.normpath(f'{cat_dog_other_root}/{split}/{class_name}')\n","        i = len(os.listdir(dest_dir))\n","        for image in source:\n","            file_name = os.path.basename(image)\n","            file_ext = os.path.splitext(file_name)[1]\n","            dest_name = f'{class_name}_{split}_{i}_{file_ext}'\n","            dest_file = os.path.normpath(f'{dest_dir}/{dest_name}')\n","            if not os.path.exists(dest_file):\n","                shutil.copy(image, dest_file)\n","                i += 1\n","\n","print(f'{skipped} files were skipped because they were already copied')"]},{"cell_type":"markdown","id":"26dcfcfb","metadata":{"papermill":{"duration":0.003348,"end_time":"2025-04-27T14:02:39.876893","exception":false,"start_time":"2025-04-27T14:02:39.873545","status":"completed"},"tags":[]},"source":["## Get Imagenet cats, dogs, and other"]},{"cell_type":"code","execution_count":8,"id":"86df5f7d","metadata":{"execution":{"iopub.execute_input":"2025-04-27T14:02:39.88537Z","iopub.status.busy":"2025-04-27T14:02:39.885046Z","iopub.status.idle":"2025-04-27T14:02:39.907839Z","shell.execute_reply":"2025-04-27T14:02:39.906734Z"},"papermill":{"duration":0.028921,"end_time":"2025-04-27T14:02:39.909323","exception":false,"start_time":"2025-04-27T14:02:39.880402","status":"completed"},"tags":[]},"outputs":[{"name":"stdout","output_type":"stream","text":["There are 1000 in the dataset.\n"]}],"source":["# We first need the class names and the labels used by the imagenet dataset\n","# Load miniimagenet object classes\n","with open('/kaggle/input/miniimagenet/ImageNet-Mini/imagenet_class_index.json') as f:\n","    obj_classes = json.load(f)\n","    obj_classes = [(i, *obj_classes[str(i)]) for i, obj_class in enumerate(obj_classes)]\n","    class_names = {class_key: class_name for idx, class_key, class_name in obj_classes}\n","    \n","print(f'There are {len(class_names)} in the dataset.')"]},{"cell_type":"code","execution_count":9,"id":"5cd1c596","metadata":{"execution":{"iopub.execute_input":"2025-04-27T14:02:39.918171Z","iopub.status.busy":"2025-04-27T14:02:39.917863Z","iopub.status.idle":"2025-04-27T14:02:39.930447Z","shell.execute_reply":"2025-04-27T14:02:39.929471Z"},"papermill":{"duration":0.018772,"end_time":"2025-04-27T14:02:39.931988","exception":false,"start_time":"2025-04-27T14:02:39.913216","status":"completed"},"tags":[]},"outputs":[{"name":"stdout","output_type":"stream","text":["Found\n","\t56 dog classes,\n","\t9 cat classes,and\n","\t935 other classes\n"]}],"source":["# Find dog and cat classes\n","dog_indices = []\n","cat_indices = []\n","other_indices = []\n","\n","for idx, key, name in obj_classes:\n","    # For dogs, we look for common dog breeds and the word 'dog'\n","    if (('dog' in name.lower() or \n","        'hound' in name.lower() or \n","        'terrier' in name.lower() or \n","        'shepherd' in name.lower() or\n","        'retriever' in name.lower() or\n","        'spaniel' in name.lower() or\n","        'poodle' in name.lower() or\n","        'collie' in name.lower()) and not (\n","        'hotdog' in name.lower() or\n","        'dogsled' in name.lower()\n","        )):\n","        dog_indices.append(idx)\n","    elif ('cat' in name.lower() or \n","        'tabby' in name.lower() or \n","        'siamese' in name.lower() or\n","        'persian' in name.lower()):\n","        cat_indices.append(idx)\n","    else:\n","        other_indices.append(idx)\n","\n","dog_classes = [obj_classes[idx][1] for idx in dog_indices]\n","cat_classes = [obj_classes[idx][1] for idx in cat_indices]\n","other_classes = [obj_classes[idx][1] for idx in other_indices]\n","\n","print(\"Found\")\n","print(f\"\\t{len(dog_indices)} dog classes,\")\n","print(f\"\\t{len(cat_indices)} cat classes,and\")\n","print(f\"\\t{len(other_indices)} other classes\")\n","\n","# Save text files for documentation containing the new class taxonomy\n","for indices, cls in zip((dog_indices, cat_indices, other_indices), ('dog', 'cat', 'other')):\n","    with open(os.path.join(cat_dog_other_root, f'{cls}_classes.txt'), 'w') as f:\n","        classes = [obj_classes[idx] for idx in indices]\n","        classes = [f\"{i}. {key}: {class_name}\" for i, key, class_name in classes]\n","        f.write(\"\\n\".join(classes))"]},{"cell_type":"code","execution_count":10,"id":"4cb336d9","metadata":{"execution":{"iopub.execute_input":"2025-04-27T14:02:39.941162Z","iopub.status.busy":"2025-04-27T14:02:39.940853Z","iopub.status.idle":"2025-04-27T14:02:50.803233Z","shell.execute_reply":"2025-04-27T14:02:50.802036Z"},"papermill":{"duration":10.869087,"end_time":"2025-04-27T14:02:50.805067","exception":false,"start_time":"2025-04-27T14:02:39.93598","status":"completed"},"tags":[]},"outputs":[{"name":"stdout","output_type":"stream","text":["Found 56 dog classes, 9 cat classes, and 935 other classes.\n","Total number of classes: 1000 (should add up to 1000)\n"]}],"source":["imagenet_images_dir = '/kaggle/input/miniimagenet/ImageNet-Mini/images'\n","\n","imagenet_dogs = []\n","imagenet_cats = []\n","imagenet_other = []\n","\n","# Walk through imagenet dataset and sort the dog, cat, and other classes\n","for dirname, dirnames, filenames in os.walk(imagenet_images_dir):\n","    # Get class key\n","    class_key = os.path.basename(dirname)\n","    # See if it matches cat, dog, or other\n","    if class_key in dog_classes:\n","        imagenet_dogs.append(dirname)\n","    if class_key in cat_classes:\n","        imagenet_cats.append(dirname)\n","    if class_key in other_classes:\n","        imagenet_other.append(dirname)\n","\n","print(f'Found {len(imagenet_dogs)} dog classes, {len(imagenet_cats)} cat classes, and {len(imagenet_other)} other classes.')\n","print(f'Total number of classes: {len(imagenet_dogs) + len(imagenet_cats) + len(imagenet_other)} (should add up to 1000)')\n","    "]},{"cell_type":"code","execution_count":11,"id":"a34914a5","metadata":{"execution":{"iopub.execute_input":"2025-04-27T14:02:50.816651Z","iopub.status.busy":"2025-04-27T14:02:50.81629Z","iopub.status.idle":"2025-04-27T14:02:51.410585Z","shell.execute_reply":"2025-04-27T14:02:51.409427Z"},"papermill":{"duration":0.601728,"end_time":"2025-04-27T14:02:51.412072","exception":false,"start_time":"2025-04-27T14:02:50.810344","status":"completed"},"tags":[]},"outputs":[{"name":"stdout","output_type":"stream","text":["Collected\n"," 202 dog images\n"," 44 cat images\n"," 3677 other images\n","from miniimagenet dataset\n"]}],"source":["# Now that we've got the directories for cats, dogs and other,\n","# we collect a list with the actual images\n","imagenet_dog_images = []\n","imagenet_cat_images = []\n","imagenet_other_images = []\n","\n","for superclass, dirs, images in zip(\n","    ('dog', 'cat', 'other'), \n","    (imagenet_dogs, imagenet_cats, imagenet_other),\n","    (imagenet_dog_images, imagenet_cat_images, imagenet_other_images)\n","    ):\n","    # Get list of files\n","    for dirname in dirs:\n","        filenames = os.listdir(dirname)\n","        filenames = [os.path.normpath(f'{dirname}/{f}') for f in filenames if os.path.splitext(f)[1].lower() == '.jpeg']\n","        images.extend(filenames)\n","\n","print('Collected')\n","print(f' {len(imagenet_dog_images)} dog images')\n","print(f' {len(imagenet_cat_images)} cat images')\n","print(f' {len(imagenet_other_images)} other images')\n","print('from miniimagenet dataset')"]},{"cell_type":"code","execution_count":12,"id":"079abeb2","metadata":{"execution":{"iopub.execute_input":"2025-04-27T14:02:51.4213Z","iopub.status.busy":"2025-04-27T14:02:51.420937Z","iopub.status.idle":"2025-04-27T14:03:31.971763Z","shell.execute_reply":"2025-04-27T14:03:31.970556Z"},"papermill":{"duration":40.55757,"end_time":"2025-04-27T14:03:31.973678","exception":false,"start_time":"2025-04-27T14:02:51.416108","status":"completed"},"tags":[]},"outputs":[],"source":["# Now shuffle split the imagenet images\n","cat_images = shuffle_split(imagenet_cat_images, train_size, test_size, dev_size)\n","dog_images = shuffle_split(imagenet_dog_images, train_size, test_size, dev_size)\n","other_images = shuffle_split(imagenet_other_images, train_size, test_size, dev_size)\n","\n","# Add the images to the new dataset\n","skipped = 0\n","for (class_name, splits) in zip(('cat', 'dog', 'other'), (cat_images, dog_images, other_images)):\n","    for (split, source) in zip(('train', 'test', 'dev'), splits):\n","        dest_dir = os.path.normpath(f'{cat_dog_other_root}/{split}/{class_name}')\n","        i = len(os.listdir(dest_dir))\n","        for img in source:\n","            file_name = os.path.basename(img)\n","            file_ext = os.path.splitext(file_name)[1]\n","            dest_name = f'{class_name}_{split}_{i}_{file_ext}'\n","            dest_file = os.path.normpath(f'{dest_dir}/{dest_name}')\n","            if not os.path.exists(dest_file):\n","                shutil.copy(img, dest_file)\n","                i += 1"]},{"cell_type":"code","execution_count":null,"id":"40325713","metadata":{"papermill":{"duration":0.003632,"end_time":"2025-04-27T14:03:31.981854","exception":false,"start_time":"2025-04-27T14:03:31.978222","status":"completed"},"tags":[]},"outputs":[],"source":[]}],"metadata":{"kaggle":{"accelerator":"none","dataSources":[{"datasetId":23777,"sourceId":30378,"sourceType":"datasetVersion"},{"datasetId":2699197,"sourceId":4642980,"sourceType":"datasetVersion"}],"dockerImageVersionId":31012,"isGpuEnabled":false,"isInternetEnabled":true,"language":"python","sourceType":"notebook"},"kernelspec":{"display_name":"Python 3","language":"python","name":"python3"},"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.11.11"},"papermill":{"default_parameters":{},"duration":164.030215,"end_time":"2025-04-27T14:03:32.405784","environment_variables":{},"exception":null,"input_path":"__notebook__.ipynb","output_path":"__notebook__.ipynb","parameters":{},"start_time":"2025-04-27T14:00:48.375569","version":"2.6.0"}},"nbformat":4,"nbformat_minor":5}